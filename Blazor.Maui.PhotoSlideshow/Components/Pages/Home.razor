@page "/"
@using PhotoSlideshow.Services
@using PhotoSlideshow.Models
@inject SlideshowService SlideshowService
@inject ImageCacheService ImageCacheService
@inject ImageConverterService ImageConverter
@implements IDisposable

<div class="slideshow-container">
    @if (_currentImages.Any())
    {
        <div class="mosaic-grid @(SlideshowService.IsAnimationRunning ? "animated" : "")">
            @foreach (var image in _currentImages)
            {
                @if (!string.IsNullOrEmpty(image.CachedPath) && !image.IsFullScreen)
                {
                    <div class="image-item"
                         style="opacity: @image.Opacity;">
                        @* Afficher la MINIATURE en mosaïque *@
                        <img src="@GetImageSource(image.CachedPath)" alt="Photo" loading="lazy" />
                    </div>
                }
            }
        </div>

        @* SÉPARÉ: Image plein écran en dehors de la grille *@
        @foreach (var image in _currentImages.Where(img => img.IsFullScreen))
        {
            @if (!string.IsNullOrEmpty(image.FullscreenPath))
            {
                <div class="fullscreen-overlay" style="opacity: @image.Opacity;">
                    @* CORRECTION: Vérifier si l'image est en cache avant affichage *@
                    @if (_fullscreenImageBase64 != null)
                    {
                        <img src="@_fullscreenImageBase64" alt="Photo plein écran" />
                    }
                    else
                    {
                        <div class="loading">Chargement de l'image...</div>
                    }
                </div>
            }
        }
    }
    else
    {
        <div class="loading">
            <p>Scan du réseau en cours...</p>
            <p>L'affichage démarrera dès les premières images trouvées</p>
        </div>
    }
</div>

<div class="controls">
    <button @onclick="ToggleAnimation">@(_isRunning ? "Pause" : "Démarrer")</button>
    <button @onclick="ClearCacheAndReload">Vider le cache</button>
    <button @onclick="ToggleSettings">⚙️ Paramètres</button>
    <div class="status">
        @if (!SlideshowService.IsLoadingComplete)
        {
            <p>Chargement: @SlideshowService.LoadedImages / @SlideshowService.TotalImages</p>
            @if (SlideshowService.TotalImages > 0)
            {
                <progress value="@SlideshowService.LoadedImages" max="@SlideshowService.TotalImages"></progress>
            }
        }
        else
        {
            <p>✓ @SlideshowService.TotalImages images chargées</p>
        }
        @* NOUVEAU: Afficher les stats du cache *@
        <p style="font-size: 0.8em; opacity: 0.7;">Cache: @_cacheStats.count images (@_cacheStats.pending en cours)</p>
    </div>
</div>

@if (_showSettings)
{
    <div class="settings-panel">
        <h3>Configuration</h3>
        <div class="form-group">
            <label for="networkFolder">Chemin réseau des photos:</label>
            <input type="text" id="networkFolder" @bind="_networkFolderInput" placeholder="\\SERVEUR\dossier\photos" />
        </div>
        <div class="settings-buttons">
            <button @onclick="SaveSettings" class="btn-primary">Enregistrer</button>
            <button @onclick="ToggleSettings" class="btn-secondary">Annuler</button>
        </div>
    </div>
}

@code {
    private bool _isRunning = false;
    private bool _showSettings = false;
    private string _networkFolderInput = string.Empty;
    private List<ImageItem> _currentImages = new();
    private Dictionary<string, string> _imageSourceCache = new();
    private string? _fullscreenImageBase64 = null; // NOUVEAU: Cache dédié pour l'image plein écran
    
    // OPTIMISÉ: Compteur pour debouncing des rafraîchissements UI
    private int _imageUpdateCounter = 0;
    private const int UI_UPDATE_BATCH_SIZE = 20;
    private (int count, int pending) _cacheStats = (0, 0);

    protected override async Task OnInitializedAsync()
    {
        _networkFolderInput = ImageCacheService.NetworkFolder;

        SlideshowService.OnImagesChanged += OnImagesChanged;
        SlideshowService.OnFullScreenChanged += OnFullScreenChanged;

        await SlideshowService.InitializeAsync();
        UpdateImageSnapshot();

        // Précharger les premières images visibles en arrière-plan
        _ = PreloadVisibleImagesAsync();

        // Démarrer l'animation automatiquement après un court délai
        await Task.Delay(2000);
        if (_currentImages.Any() && !_isRunning)
        {
            ToggleAnimation();
        }

        // NOUVEAU: Timer pour mettre à jour les stats du cache
        _ = UpdateCacheStatsLoop();
    }

    /// <summary>
    /// OPTIMISÉ: Obtenir la source de l'image (Base64) avec chargement progressif
    /// </summary>
    private string GetImageSource(string imagePath)
    {
        // Si déjà en cache local, retourner immédiatement
        if (_imageSourceCache.TryGetValue(imagePath, out var source))
            return source;

        // Retourner un placeholder et charger en arrière-plan
        _ = LoadImageSourceAsync(imagePath);

        return "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='100' height='100'%3E%3Crect fill='%232a2a2a' width='100' height='100'/%3E%3C/svg%3E";
    }

    /// <summary>
    /// OPTIMISÉ: Charger l'image de manière asynchrone avec cache local
    /// </summary>
    private async Task LoadImageSourceAsync(string imagePath)
    {
        try
        {
            var source = await ImageConverter.ConvertToBase64Async(imagePath);
            _imageSourceCache[imagePath] = source;

            // Rafraîchir l'UI uniquement si nécessaire
            await InvokeAsync(StateHasChanged);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Erreur chargement image: {ex.Message}");
        }
    }

    /// <summary>
    /// OPTIMISÉ: Précharger uniquement les images visibles
    /// </summary>
    private async Task PreloadVisibleImagesAsync()
    {
        // Limiter le préchargement aux 50 premières images pour éviter la surcharge
        var imagesToPreload = _currentImages
            .Take(50)
            .Where(img => !string.IsNullOrEmpty(img.CachedPath))
            .Select(img => img.CachedPath!)
            .ToList();

        // Précharger par lots de 10 pour ne pas surcharger
        foreach (var batch in imagesToPreload.Chunk(10))
        {
            var tasks = batch.Select(path => LoadImageSourceAsync(path));
            await Task.WhenAll(tasks);
            await Task.Delay(100); // Petit délai entre les lots
        }
    }

    /// <summary>
    /// NOUVEAU: Mise à jour périodique des stats du cache
    /// </summary>
    private async Task UpdateCacheStatsLoop()
    {
        while (!_isDisposed)
        {
            _cacheStats = ImageConverter.GetCacheStats();
            await Task.Delay(2000);
        }
    }

    private bool _isDisposed = false;

    /// <summary>
    /// OPTIMISÉ: Debouncing - rafraîchir UI tous les 20 images au lieu de chaque fois
    /// </summary>
    private void OnImagesChanged()
    {
        _imageUpdateCounter++;
        
        // Rafraîchir uniquement tous les N images OU quand le chargement est terminé
        if (_imageUpdateCounter % UI_UPDATE_BATCH_SIZE == 0 || SlideshowService.IsLoadingComplete)
        {
            InvokeAsync(() =>
            {
                UpdateImageSnapshot();
                
                // CORRECTION: Réinitialiser l'image plein écran si fermée
                var hasFullscreen = _currentImages.Any(img => img.IsFullScreen);
                if (!hasFullscreen)
                {
                    _fullscreenImageBase64 = null;
                }
                
                StateHasChanged();
                
                // Précharger les nouvelles images
                _ = PreloadVisibleImagesAsync();
            });
        }
        else
        {
            // Mise à jour silencieuse sans StateHasChanged()
            UpdateImageSnapshot();
        }
    }

    private void OnFullScreenChanged(int index)
    {
        InvokeAsync(async () =>
        {
            UpdateImageSnapshot();

            // CORRECTION: Charger l'image plein écran AVANT de rafraîchir l'UI
            var fullscreenImage = _currentImages.FirstOrDefault(img => img.IsFullScreen);
            if (fullscreenImage?.FullscreenPath != null)
            {
                Console.WriteLine($"🔄 Chargement image plein écran: {Path.GetFileName(fullscreenImage.FullscreenPath)}");
                
                _fullscreenImageBase64 = null; // Réinitialiser
                StateHasChanged(); // Afficher "Chargement..."
                
                // Charger l'image
                _fullscreenImageBase64 = await ImageConverter.ConvertToBase64Async(fullscreenImage.FullscreenPath);
                
                if (string.IsNullOrEmpty(_fullscreenImageBase64))
                {
                    Console.WriteLine($"❌ Échec chargement image plein écran");
                }
                else
                {
                    Console.WriteLine($"✅ Image plein écran chargée ({_fullscreenImageBase64.Length} caractères)");
                }
            }
            else
            {
                _fullscreenImageBase64 = null;
            }

            StateHasChanged();
        });
    }

    private void UpdateImageSnapshot()
    {
        _currentImages = SlideshowService.Images.ToList();
    }

    private void ToggleAnimation()
    {
        if (_isRunning)
        {
            SlideshowService.StopAnimation();
        }
        else
        {
            SlideshowService.StartAnimation();
        }
        _isRunning = !_isRunning;
    }

    private void ToggleSettings()
    {
        _showSettings = !_showSettings;
        if (_showSettings)
        {
            _networkFolderInput = ImageCacheService.NetworkFolder;
        }
    }

    private async Task SaveSettings()
    {
        if (!string.IsNullOrWhiteSpace(_networkFolderInput))
        {
            ImageCacheService.NetworkFolder = _networkFolderInput;
            _showSettings = false;
            await ClearCacheAndReload();
        }
    }

    private async Task ClearCacheAndReload()
    {
        SlideshowService.StopAnimation();
        _isRunning = false;
        ImageConverter.ClearCache();
        _imageSourceCache.Clear();
        _fullscreenImageBase64 = null;
        _imageUpdateCounter = 0;

        await SlideshowService.InitializeAsync();
        UpdateImageSnapshot();
        StateHasChanged();
    }

    public void Dispose()
    {
        _isDisposed = true;
        SlideshowService.OnImagesChanged -= OnImagesChanged;
        SlideshowService.OnFullScreenChanged -= OnFullScreenChanged;
        SlideshowService.StopAnimation();
        _imageSourceCache.Clear();
        _fullscreenImageBase64 = null;
        ImageConverter.ClearCache();
    }
}